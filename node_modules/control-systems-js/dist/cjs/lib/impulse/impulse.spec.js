"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const calculateTransferFunction_1 = require("../math/calculateTransferFunction/implementations/calculateTransferFunction");
const complex_1 = require("../math/complex");
const convolution_1 = require("../math/convolution/convolution");
const gaverStehfest_1 = require("../math/inverseLaplace/implementations/gaverStehfest");
const PolynomialOperations_1 = require("../math/polynomialOperations/implementations/PolynomialOperations");
const impulse_1 = require("./impulse");
(0, vitest_1.describe)('Step class', () => {
    let impulse;
    let calculateTf;
    let inverseLaplace;
    let convolution;
    let polOps;
    (0, vitest_1.beforeEach)(() => {
        calculateTf = new calculateTransferFunction_1.CalculateTransferFunction();
        inverseLaplace = new gaverStehfest_1.GaverStehfest();
        polOps = new PolynomialOperations_1.PolynomialOperations();
        convolution = new convolution_1.Convolution(polOps);
        impulse = new impulse_1.Impulse(calculateTf, inverseLaplace, convolution);
    });
    (0, vitest_1.it)('Should calculate the points for a stable response (s^2 + 3s + 4)/(2s^3 + 5s^2 + 6s + 8)', () => {
        const timeRange = [0, 2.5, 5, 7.5, 10, 12.5, 15, 17.5, 20, 22.5, 25, 27.5, 30];
        const tf = {
            numerator: [(0, complex_1.complex)(1, 0), (0, complex_1.complex)(3, 0), (0, complex_1.complex)(4, 0)],
            denominator: [(0, complex_1.complex)(2, 0), (0, complex_1.complex)(5, 0), (0, complex_1.complex)(6, 0), (0, complex_1.complex)(8, 0)],
        };
        const points = impulse.calculatePoints(tf, timeRange);
        const expectedPoints = [
            5.0e-1, -2.4265e-1, 1.6046e-1, -9.2126e-2, 4.7065e-2, -2.1134e-2, 7.8584e-3, -1.8808e-3, -3.5213e-4, 8.9446e-4,
            -8.0239e-4, 5.5403e-4, -3.2961e-4,
        ];
        // Points should match
        // TODO: check inverse laplace implementation, to improve precision
        points.forEach((point, index) => {
            (0, vitest_1.expect)(point === null || point === void 0 ? void 0 : point.x).toBeCloseTo(timeRange[index], 1);
            (0, vitest_1.expect)(point === null || point === void 0 ? void 0 : point.y).toBeCloseTo(expectedPoints[index], 1);
        });
    });
    (0, vitest_1.it)('Should calculate the points for a stable response (s + 3)/(s^3 + 3s^2 + 5s + 1)', () => {
        const timeRange = [0, 2.5, 5, 7.5, 10, 12.5, 15, 17.5, 20, 22.5, 25, 27.5, 30];
        const tf = {
            numerator: [(0, complex_1.complex)(1, 0), (0, complex_1.complex)(3, 0)],
            denominator: [(0, complex_1.complex)(1, 0), (0, complex_1.complex)(3, 0), (0, complex_1.complex)(5, 0), (0, complex_1.complex)(1, 0)],
        };
        const points = impulse.calculatePoints(tf, timeRange);
        const expectedPoints = [
            0, 0.4275, 0.2331, 0.1314, 0.0741, 0.0418, 0.0236, 0.0133, 0.0075, 0.0042, 0.0024, 0.0013, 0.0008,
        ];
        // Points should match
        // TODO: check inverse laplace implementation, to improve precision
        points.forEach((point, index) => {
            (0, vitest_1.expect)(point === null || point === void 0 ? void 0 : point.x).toBeCloseTo(timeRange[index], 1);
            (0, vitest_1.expect)(point === null || point === void 0 ? void 0 : point.y).toBeCloseTo(expectedPoints[index], 1);
        });
    });
});
//# sourceMappingURL=../../../../src/lib/impulse/impulse.spec.js.map