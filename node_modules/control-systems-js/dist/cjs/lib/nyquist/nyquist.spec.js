"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const calculateTransferFunction_1 = require("../math/calculateTransferFunction/implementations/calculateTransferFunction");
const complex_1 = require("../math/complex");
const nyquist_1 = require("./nyquist");
(0, vitest_1.describe)('Nyquist class', () => {
    let nyquist;
    let calculateTransferFunction;
    let calculationSpy;
    (0, vitest_1.beforeEach)(() => {
        calculateTransferFunction = new calculateTransferFunction_1.CalculateTransferFunction();
        calculationSpy = vitest_1.vi.spyOn(calculateTransferFunction, 'calculateValue');
        nyquist = new nyquist_1.Nyquist(calculateTransferFunction);
    });
    (0, vitest_1.it)('Should calculate correctly the real and imaginary data given a set of frequencies', () => {
        //  s + 2 / 2 s + 1
        const transferFunction = {
            numerator: [(0, complex_1.complex)(1, 0), (0, complex_1.complex)(2, 0)],
            denominator: [(0, complex_1.complex)(2, 0), (0, complex_1.complex)(1, 0)],
        };
        const resultValues = { re: 2, im: -0.003 };
        calculationSpy.mockReturnValue((0, complex_1.complex)(resultValues.re, resultValues.im));
        const result = nyquist.calculatePoints(transferFunction, [0.001]);
        (0, vitest_1.expect)(result.points[0].x).toBeCloseTo(resultValues.re);
        (0, vitest_1.expect)(result.points[0].y).toBeCloseTo(resultValues.im);
    });
    (0, vitest_1.it)('Should flip correctly the corresponding points in the x-axis', () => {
        //  s + 2 / 2 s + 1
        const transferFunction = {
            numerator: [(0, complex_1.complex)(1, 0), (0, complex_1.complex)(2, 0)],
            denominator: [(0, complex_1.complex)(2, 0), (0, complex_1.complex)(1, 0)],
        };
        const resultValues = { re: 2, im: -0.003 };
        calculationSpy.mockReturnValue((0, complex_1.complex)(resultValues.re, resultValues.im));
        const result = nyquist.calculatePoints(transferFunction, [0.001]);
        (0, vitest_1.expect)(result.correspondingPoints[0].x).toBeCloseTo(resultValues.re);
        (0, vitest_1.expect)(result.correspondingPoints[0].y).toBeCloseTo(-resultValues.im);
    });
    (0, vitest_1.it)('Should calculate correctly all the points if multiple frequencies are passed', () => {
        //  s + 3  /  s^3 + 3 s^2 + 5 s + 1
        const transferFunction = {
            numerator: [(0, complex_1.complex)(1, 0), (0, complex_1.complex)(3, 0)],
            denominator: [(0, complex_1.complex)(3, 0), (0, complex_1.complex)(3, 0), (0, complex_1.complex)(5, 0), (0, complex_1.complex)(1, 0)],
        };
        const resultValues = [
            { re: 0.339726, im: -1.2274 },
            { re: -0.046653, im: -4.5231e-3 },
        ];
        calculationSpy.mockReturnValueOnce((0, complex_1.complex)(resultValues[0].re, resultValues[0].im));
        calculationSpy.mockReturnValueOnce((0, complex_1.complex)(resultValues[1].re, resultValues[1].im));
        const result = nyquist.calculatePoints(transferFunction, [0.5, 5]);
        (0, vitest_1.expect)(result.points[0].x).toBeCloseTo(resultValues[0].re);
        (0, vitest_1.expect)(result.points[0].y).toBeCloseTo(resultValues[0].im);
        (0, vitest_1.expect)(result.correspondingPoints[0].x).toBeCloseTo(resultValues[0].re);
        (0, vitest_1.expect)(result.correspondingPoints[0].y).toBeCloseTo(-resultValues[0].im);
        (0, vitest_1.expect)(result.points[1].x).toBeCloseTo(resultValues[1].re);
        (0, vitest_1.expect)(result.points[1].y).toBeCloseTo(resultValues[1].im);
        (0, vitest_1.expect)(result.correspondingPoints[1].x).toBeCloseTo(resultValues[1].re);
        (0, vitest_1.expect)(result.correspondingPoints[1].y).toBeCloseTo(-resultValues[1].im);
    });
});
//# sourceMappingURL=../../../../src/lib/nyquist/nyquist.spec.js.map