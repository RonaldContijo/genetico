"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const calculateTransferFunction_1 = require("../../calculateTransferFunction/implementations/calculateTransferFunction");
const complex_1 = require("../../complex");
const gaverStehfest_1 = require("./gaverStehfest");
(0, vitest_1.describe)('GaverStehfest class', () => {
    const calculateTransferFunction = new calculateTransferFunction_1.CalculateTransferFunction();
    let gaverStehfest;
    (0, vitest_1.beforeEach)(() => {
        gaverStehfest = new gaverStehfest_1.GaverStehfest();
    });
    (0, vitest_1.it)('Should be able to apply inverse laplace and evaluate it to a first order function', () => {
        // 2 / (-5s + 3)
        // âˆ’2/5* e ^(3/5 * t), t=1
        const transferFunction = {
            numerator: [(0, complex_1.complex)(2, 0)],
            denominator: [(0, complex_1.complex)(-5, 0), (0, complex_1.complex)(3, 0)],
        };
        const timeDomainResult = gaverStehfest.execute((s) => calculateTransferFunction.calculateValue(transferFunction, s), 1);
        (0, vitest_1.expect)(timeDomainResult).toBeCloseTo(-0.728847);
    });
    (0, vitest_1.it)('Should be able to apply inverse laplace and evaluate it to a third order function', () => {
        // 1 / (s^3)
        // (t^2)/2, t=10
        const transferFunction = {
            numerator: [(0, complex_1.complex)(1, 0)],
            denominator: [(0, complex_1.complex)(1, 0), (0, complex_1.complex)(0, 0), (0, complex_1.complex)(0, 0)],
        };
        const timeDomainResult = gaverStehfest.execute((s) => calculateTransferFunction.calculateValue(transferFunction, s), 10);
        (0, vitest_1.expect)(timeDomainResult).toBeCloseTo(10);
    });
    (0, vitest_1.it)('Should be able to apply inverse laplace and evaluate it to a third order functio, that return an oscilatory function', () => {
        // 1 / (s^3 + 4s)
        // 1/4(1-cos2t), t=pi/2
        const transferFunction = {
            numerator: [(0, complex_1.complex)(1, 0)],
            denominator: [(0, complex_1.complex)(1, 0), (0, complex_1.complex)(0, 0), (0, complex_1.complex)(4, 0), (0, complex_1.complex)(0, 0)],
        };
        const timeDomainResult = gaverStehfest.execute((s) => calculateTransferFunction.calculateValue(transferFunction, s), Math.PI / 2);
        (0, vitest_1.expect)(timeDomainResult).toBeCloseTo(0.5);
    });
    (0, vitest_1.it)('Should be able to apply inverse laplace and evaluate it to a fourth order function', () => {
        // 1 / (s^3)
        // 3/2 * t * sin t, t=pi/2
        const transferFunction = {
            numerator: [(0, complex_1.complex)(3, 0), (0, complex_1.complex)(0, 0)],
            denominator: [(0, complex_1.complex)(1, 0), (0, complex_1.complex)(0, 0), (0, complex_1.complex)(2, 0), (0, complex_1.complex)(0, 0), (0, complex_1.complex)(1, 0)],
        };
        const timeDomainResult = gaverStehfest.execute((s) => calculateTransferFunction.calculateValue(transferFunction, s), Math.PI / 2);
        (0, vitest_1.expect)(timeDomainResult).toBeCloseTo((3 * Math.PI) / 4);
    });
});
//# sourceMappingURL=../../../../../../src/lib/math/inverseLaplace/implementations/gaverStehfest.spec.js.map