"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GaverStehfest = void 0;
const factorial_1 = require("../../../helpers/factorial");
const complex_1 = require("../../complex");
class GaverStehfest {
    constructor() {
        this.NUMBER_OF_COEFFICIENTS = 22;
        this.SMALL_NUMBER = 10e-9;
    }
    getCoefficients1(L) {
        const nn2 = L / 2;
        const v = [];
        for (let n = 1; n <= L; n++) {
            let z = (0, complex_1.complex)(0, 0);
            for (let k = Math.floor((n + 1) / 2); k <= Math.min(n, nn2); k++) {
                const num = (0, complex_1.pow)(k, nn2);
                const den = (0, complex_1.multiply)((0, complex_1.multiply)((0, complex_1.multiply)((0, complex_1.multiply)((0, factorial_1.factorial)(nn2 - k), (0, factorial_1.factorial)(k)), (0, factorial_1.factorial)(k - 1)), (0, factorial_1.factorial)(n - k)), (0, factorial_1.factorial)(2 * k - n));
                const x = (0, complex_1.divide)((0, complex_1.multiply)(num, (0, factorial_1.factorial)(2 * k)), den);
                z = (0, complex_1.add)(z, x);
            }
            v[n - 1] = (0, complex_1.multiply)((0, complex_1.pow)(-1, n + nn2), z);
        }
        return v;
    }
    /**
     * Based on the implementations of the following links
     * https://github.com/jlapeyre/InverseLaplace.jl/blob/master/src/gaverstehfest.jl
     * https://www.cs.hs-rm.de/~weber/lapinv/gavsteh/gavsteh.htm
     * https://www.mathworks.com/matlabcentral/fileexchange/9987-gaver-stehfest-algorithm-for-inverse-laplace-transform
     * https://mpmath.org/doc/current/calculus/inverselaplace.html
     *
     * And the original research from Stehfest
     *
     * @param fn Laplace function to be transformed
     * @param t Time for the function to be evaluated at
     * @param L The number of coefficients. It depends on the computer word length used (examples: L=8, 10, 12, 14, 16, etc.)
     * @returns
     */
    gavsteh(fn, t, L) {
        const coefficients = this.getCoefficients1(L);
        const nonZeroTime = t || this.SMALL_NUMBER;
        let sum = (0, complex_1.complex)(0, 0);
        const ln2onT = (0, complex_1.divide)(Math.log(2.0), t || nonZeroTime); // Avoid division by zero
        for (let n = 1; n <= L; n++) {
            const p = (0, complex_1.multiply)(n, ln2onT);
            sum = (0, complex_1.add)(sum, (0, complex_1.multiply)(coefficients[n - 1], fn((0, complex_1.complex)(p, 0))));
        }
        return (0, complex_1.multiply)(sum, ln2onT);
    }
    /**
     * This function is an implementation of the Gaver-Stehfest method for numerical inverse Laplace transform.
     * The algorithm uses a summation of the function values evaluated at specific values,
     * multiplied by coefficients calculated using a combination of factorials and powers.
     * @param fn Laplace function to be transformed
     * @param time Time for the function to be evaluated at
     * @returns evaluated function value
     */
    execute(fn, time) {
        var _a;
        return (_a = this.gavsteh(fn, time, this.NUMBER_OF_COEFFICIENTS)) === null || _a === void 0 ? void 0 : _a.re;
    }
}
exports.GaverStehfest = GaverStehfest;
//# sourceMappingURL=../../../../../../src/lib/math/inverseLaplace/implementations/gaverStehfest.js.map