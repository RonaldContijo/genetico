"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const complex_1 = require("../../complex");
const durandKerner_1 = require("./durandKerner");
const PRECISION = 6;
const MAX_ITERATIONS = 50;
// Root order is not relevant, so the expected result and the actual result are sorted
const sortRoots = (num1, num2) => {
    if (num1.re === undefined || num2.re === undefined || num1.im === undefined || num2.im === undefined) {
        return 0;
    }
    if (num1.re < num2.re) {
        return -1;
    }
    if (num1.re > num2.re) {
        return 1;
    }
    if (num1.im < num2.im) {
        return -1;
    }
    if (num1.im > num2.im) {
        return 1;
    }
    return 0;
};
(0, vitest_1.describe)('Testing DurandKerner class to find roots of a polynomial', () => {
    (0, vitest_1.it)('Should throw an error if no coefficients are passed', () => {
        const coefficients = null;
        (0, vitest_1.expect)(() => {
            return new durandKerner_1.DurandKerner().findRoots(coefficients);
        }).toThrow();
    });
    (0, vitest_1.it)('Should return an empty array if the coefficients are empty', () => {
        const coefficients = [];
        const durandKerner = new durandKerner_1.DurandKerner();
        const roots = durandKerner.findRoots(coefficients);
        (0, vitest_1.expect)(roots).toMatchObject([]);
    });
    (0, vitest_1.it)('Should return an empty array for a constant expression', () => {
        const coefficients = [(0, complex_1.complex)(1, 0)];
        const durandKerner = new durandKerner_1.DurandKerner();
        const roots = durandKerner.findRoots(coefficients);
        (0, vitest_1.expect)(roots).toMatchObject([]);
    });
    (0, vitest_1.it)('Should return the correct roots for the equation: x² - 3x + 2', () => {
        const coefficients = [(0, complex_1.complex)(1, 0), (0, complex_1.complex)(-3, 0), (0, complex_1.complex)(2, 0)];
        const durandKerner = new durandKerner_1.DurandKerner();
        const roots = durandKerner.findRoots(coefficients, MAX_ITERATIONS, PRECISION);
        (0, vitest_1.expect)(roots).toMatchObject([
            { re: 1, im: 0 },
            { re: 2, im: 0 },
        ]);
    });
    (0, vitest_1.it)('Should return the correct roots for the equation: x² - 2x + 1', () => {
        const expectedResults = [
            { re: 1, im: 0 },
            { re: 1, im: 0 },
        ].sort(sortRoots);
        const coefficients = [(0, complex_1.complex)(1, 0), (0, complex_1.complex)(-2, 0), (0, complex_1.complex)(1, 0)];
        const durandKerner = new durandKerner_1.DurandKerner();
        const roots = durandKerner.findRoots(coefficients, MAX_ITERATIONS, PRECISION).sort(sortRoots);
        for (const [index, result] of roots.entries()) {
            (0, vitest_1.expect)(result.re).toBeCloseTo(expectedResults[index].re);
            (0, vitest_1.expect)(result.im).toBeCloseTo(expectedResults[index].im);
        }
    });
    (0, vitest_1.it)('Should return the correct roots for the equation: x⁵ - 13x³ + 36x', () => {
        const expectedResults = [
            { re: -3, im: 0 },
            { re: -2, im: 0 },
            { re: 0, im: 0 },
            { re: 2, im: 0 },
            { re: 3, im: 0 },
        ].sort(sortRoots);
        const coefficients = [(0, complex_1.complex)(1, 0), (0, complex_1.complex)(0, 0), (0, complex_1.complex)(-13, 0), (0, complex_1.complex)(0, 0), (0, complex_1.complex)(36, 0), (0, complex_1.complex)(0, 0)];
        const durandKerner = new durandKerner_1.DurandKerner();
        const roots = durandKerner.findRoots(coefficients, MAX_ITERATIONS, PRECISION).sort(sortRoots);
        for (const [index, result] of roots.entries()) {
            (0, vitest_1.expect)(result.re).toBeCloseTo(expectedResults[index].re);
            (0, vitest_1.expect)(result.im).toBeCloseTo(expectedResults[index].im);
        }
    });
    (0, vitest_1.it)('Should return the correct roots for the equation: x³ + x² + x + 1', () => {
        const expectedResults = [
            { re: -1, im: 0 },
            { re: 0, im: 1 },
            { re: 0, im: -1 },
        ];
        const coefficients = [(0, complex_1.complex)(1, 0), (0, complex_1.complex)(1, 0), (0, complex_1.complex)(1, 0), (0, complex_1.complex)(1, 0)];
        const durandKerner = new durandKerner_1.DurandKerner();
        const roots = durandKerner.findRoots(coefficients, MAX_ITERATIONS, PRECISION).sort(sortRoots);
        for (const [index, result] of roots.entries()) {
            (0, vitest_1.expect)(result.re).toBeCloseTo(expectedResults[index].re);
            (0, vitest_1.expect)(result.im).toBeCloseTo(expectedResults[index].im);
        }
    });
    (0, vitest_1.it)('Should return the correct roots for the equation: (1 + 3i)x² + (2 + 2i)x + (3 + i)', () => {
        const expectedResults = [
            { re: -8e-1, im: -6e-1 },
            { re: 0, im: 1 },
        ].sort(sortRoots);
        const coefficients = [(0, complex_1.complex)(1, 3), (0, complex_1.complex)(2, 2), (0, complex_1.complex)(3, 1)];
        const durandKerner = new durandKerner_1.DurandKerner();
        const roots = durandKerner.findRoots(coefficients, MAX_ITERATIONS, PRECISION).sort(sortRoots);
        for (const [index, result] of roots.entries()) {
            (0, vitest_1.expect)(result.re).toBeCloseTo(expectedResults[index].re);
            (0, vitest_1.expect)(result.im).toBeCloseTo(expectedResults[index].im);
        }
    });
    (0, vitest_1.it)('Should return the correct roots for the equation: (1 + i)x³ + (2 + 2i)x² + (3 + 3i)x + (4 + 4i)', () => {
        const expectedResults = [
            { re: -1.650629, im: 0 },
            { re: -1.74685e-1, im: 1.5468688872 },
            { re: -1.74685e-1, im: -1.5468688872 },
        ].sort(sortRoots);
        const coefficients = [(0, complex_1.complex)(1, 1), (0, complex_1.complex)(2, 2), (0, complex_1.complex)(3, 3), (0, complex_1.complex)(4, 4)];
        const durandKerner = new durandKerner_1.DurandKerner();
        const roots = durandKerner.findRoots(coefficients, MAX_ITERATIONS, PRECISION).sort(sortRoots);
        for (const [index, result] of roots.entries()) {
            (0, vitest_1.expect)(result.re).toBeCloseTo(expectedResults[index].re);
            (0, vitest_1.expect)(result.im).toBeCloseTo(expectedResults[index].im);
        }
    });
});
//# sourceMappingURL=../../../../../../src/lib/math/rootFinding/implementations/durandKerner.spec.js.map