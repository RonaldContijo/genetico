"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DurandKerner = void 0;
const complex_1 = require("../../complex");
const COMPLEX_ONE = (0, complex_1.complex)(1, 0);
/**
 * Implementation of a root finding algorithm.
 * Based on Dr. John B. Matthews's [Java implementation](https://sites.google.com/site/drjohnbmatthews/polyroots/source)
 */
class DurandKerner {
    constructor() {
        /**
         * Transform polynomial coefficients to comply to a monic form
         * @param coefficients
         */
        this.toMonicForm = (coefficients) => {
            var _a, _b;
            let monicCoefficients = [...coefficients];
            if (coefficients[0] && !(((_a = coefficients[0]) === null || _a === void 0 ? void 0 : _a.re) === 1 && ((_b = coefficients[0]) === null || _b === void 0 ? void 0 : _b.im) === 0)) {
                monicCoefficients = coefficients.map((coefficient) => (0, complex_1.divide)(coefficient, coefficients[0]));
            }
            return monicCoefficients;
        };
    }
    /**
     * Check if the arrays have converged, meaning that the delta for each value inside both arrays
     * are less than the tolerance passed
     * @param valuesA
     * @param valuesB
     * @param tolerance
     */
    hasConverged(valuesA, valuesB, tolerance) {
        for (const [index, a] of valuesA.entries()) {
            const b = valuesB[index];
            // Check if difference between both values are within the tolerance
            const delta = (0, complex_1.subtract)(a, b);
            if (!((0, complex_1.abs)(delta.re) < tolerance) || !((0, complex_1.abs)(delta.im) < tolerance)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Evaluates polynomial according to a given value.
     * It uses the [Horner's method](https://en.wikipedia.org/wiki/Horner%27s_method) for evaluation
     * @param coefficients
     * @param value
     */
    evalPolynomial(coefficients, value) {
        // Slice(1) to start from index 1 the reduce function
        const result = coefficients.slice(1).reduce((prev, curr) => {
            return (0, complex_1.add)((0, complex_1.multiply)(prev, value), curr);
        }, coefficients[0]);
        return result;
    }
    /**
     * Creates an array with the initial root guesses
     * @param polynomialOrder
     * @param initialResult
     */
    generateInitialRootGuess(polynomialOrder, initialResult) {
        const initialGuess = [];
        initialGuess.push(COMPLEX_ONE);
        for (let i = 1; i < polynomialOrder - 1; i++) {
            initialGuess[i] = (0, complex_1.multiply)(initialGuess[i - 1], initialResult);
        }
        return initialGuess;
    }
    /**
     * Calculates the roots of a polynomial
     * @param initialRoots
     * @param initialResult
     * @param maxIterations
     * @param tolerance
     */
    calculateRoots(coefficients, initialRoots, initialResult, maxIterations, tolerance) {
        let a0 = [...initialRoots];
        const a1 = [];
        let result = initialResult;
        let iterCount = 0;
        // eslint-disable-next-line no-constant-condition
        while (true) {
            for (let i = 0; i < a0.length; i++) {
                result = COMPLEX_ONE;
                for (let j = 0; j < a0.length; j++) {
                    if (i !== j) {
                        result = (0, complex_1.multiply)((0, complex_1.subtract)(a0[i], a0[j]), result);
                    }
                }
                // fixed point iteration
                // x_(n+1) = x_n - f(x_n)/(x_n - q)(x_n-r)(x_n - p)...
                a1[i] = (0, complex_1.subtract)(a0[i], (0, complex_1.divide)(this.evalPolynomial(coefficients, a0[i]), result));
            }
            iterCount += 1;
            if (iterCount > maxIterations) {
                throw new Error('Could not calculate the roots for the given function, please try to increase the max iterations allowed');
            }
            if (this.hasConverged(a0, a1, tolerance)) {
                break;
            }
            a0 = [...a1];
        }
        return a1;
    }
    /**
     * Applies the precision to each calculated root
     * @param roots
     * @param precision
     */
    setRootsPrecision(roots, precision) {
        return roots.map((root) => (0, complex_1.complex)(Number(root.re.toPrecision(precision)), Number(root.im.toPrecision(precision))));
    }
    /**
     * Find all the roots from a polynomial. It applies the Durandâ€“Kerner (or Weierstrass) method.
     * The array should have the highest order coefficient first.
     * @param maxIterations
     * @param precision
     * @param tolerance
     */
    findRoots(coefficients, maxIterations = 20 * Math.pow(coefficients.length, 2), precision = 6, tolerance = 10e-6) {
        if (!coefficients || !Array.isArray(coefficients)) {
            throw new Error('Missing or invalid coefficients');
        }
        if (coefficients.length === 0 || coefficients.length === 1) {
            return [];
        }
        const monicCoefficients = (coefficients = this.toMonicForm(coefficients));
        const initialResult = (0, complex_1.complex)(0.4, 0.9);
        const initialRoots = this.generateInitialRootGuess(monicCoefficients.length, initialResult);
        const roots = this.calculateRoots(monicCoefficients, initialRoots, initialResult, maxIterations, tolerance);
        const rootsWithPrecision = this.setRootsPrecision(roots, precision);
        return rootsWithPrecision;
    }
}
exports.DurandKerner = DurandKerner;
//# sourceMappingURL=../../../../../../src/lib/math/rootFinding/implementations/durandKerner.js.map