"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const complex_1 = require("../../complex");
const calculateTransferFunction_1 = require("./calculateTransferFunction");
(0, vitest_1.describe)('CalculateTransferFunction class', () => {
    let calculateTransferFunction;
    (0, vitest_1.beforeEach)(() => {
        calculateTransferFunction = new calculateTransferFunction_1.CalculateTransferFunction();
    });
    (0, vitest_1.it)('Should calculate correctly first order transfer functions', () => {
        // s / 2s
        const functionExpression = {
            numerator: [(0, complex_1.complex)(1, 0), (0, complex_1.complex)(0, 0)],
            denominator: [(0, complex_1.complex)(2, 0), (0, complex_1.complex)(0, 0)],
        };
        const s = (0, complex_1.complex)(5, 0);
        const result = calculateTransferFunction.calculateValue(functionExpression, s);
        (0, vitest_1.expect)(result).toBeDefined();
        (0, vitest_1.expect)(result.re).toBeCloseTo(0.5);
        (0, vitest_1.expect)(result.im).toBe(0);
    });
    (0, vitest_1.it)('Should calculate correctly second order transfer functions', () => {
        // (s^2 + 3 s + 2)/(s^2 + 4s + 5)
        const functionExpression = {
            numerator: [(0, complex_1.complex)(1, 0), (0, complex_1.complex)(3, 0), (0, complex_1.complex)(2, 0)],
            denominator: [(0, complex_1.complex)(1, 0), (0, complex_1.complex)(4, 0), (0, complex_1.complex)(5, 0)],
        };
        const s = (0, complex_1.complex)(10, 0);
        const result = calculateTransferFunction.calculateValue(functionExpression, s);
        (0, vitest_1.expect)(result).toBeDefined();
        (0, vitest_1.expect)(result.re).toBeCloseTo(0.9103);
        (0, vitest_1.expect)(result.im).toBe(0);
    });
    (0, vitest_1.it)('Should calculate correctly higher order transfer functions', () => {
        // (s^2 + 3 s + 2)/( 2s^3 + 4s^2 + 5 s + 5)
        const functionExpression = {
            numerator: [(0, complex_1.complex)(1, 0), (0, complex_1.complex)(3, 0), (0, complex_1.complex)(2, 0)],
            denominator: [(0, complex_1.complex)(2, 0), (0, complex_1.complex)(4, 0), (0, complex_1.complex)(5, 0), (0, complex_1.complex)(5, 0)],
        };
        const s = (0, complex_1.complex)(15, 0);
        const result = calculateTransferFunction.calculateValue(functionExpression, s);
        (0, vitest_1.expect)(result).toBeDefined();
        (0, vitest_1.expect)(result.re).toBeCloseTo(0.03518);
        (0, vitest_1.expect)(result.im).toBe(0);
    });
    (0, vitest_1.it)('Should calculate correctly higher order transfer functions with complex numbers', () => {
        // (s^2 + 3 s + 2)/( 2s^3 + 4s^2 + 5 s + 5)
        const functionExpression = {
            numerator: [(0, complex_1.complex)(1, 0), (0, complex_1.complex)(3, 0), (0, complex_1.complex)(2, 0)],
            denominator: [(0, complex_1.complex)(2, 0), (0, complex_1.complex)(4, 0), (0, complex_1.complex)(5, 0), (0, complex_1.complex)(5, 0)],
        };
        const s = (0, complex_1.complex)(10, 1);
        const result = calculateTransferFunction.calculateValue(functionExpression, s);
        (0, vitest_1.expect)(result).toBeDefined();
        (0, vitest_1.expect)(result.re).toBeCloseTo(0.05319);
        (0, vitest_1.expect)(result.im).toBeCloseTo(-0.00557);
    });
});
//# sourceMappingURL=../../../../../../src/lib/math/calculateTransferFunction/implementations/calculateTransferFunction.spec.js.map