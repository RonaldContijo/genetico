"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const complex_1 = require("../complex");
const frequencyRange_1 = require("./frequencyRange");
(0, vitest_1.describe)('FrequencyRange', () => {
    let frequencyRange;
    (0, vitest_1.beforeEach)(() => {
        frequencyRange = new frequencyRange_1.FrequencyRange();
    });
    (0, vitest_1.describe)('getDefault', () => {
        (0, vitest_1.it)('should return an array of length NUM_OF_SAMPLES', () => {
            const poles = [(0, complex_1.complex)(-1, 0), (0, complex_1.complex)(-2, 0), (0, complex_1.complex)(-3, 0)];
            const zeros = [(0, complex_1.complex)(0, 0), (0, complex_1.complex)(-4, 0)];
            const frequencyRangeValues = frequencyRange.getDefault(poles, zeros);
            (0, vitest_1.expect)(frequencyRangeValues.length).toEqual(1000);
        });
        (0, vitest_1.it)('should return a range of frequencies between omegaMin and omegaMax', () => {
            const poles = [(0, complex_1.complex)(-1, 0), (0, complex_1.complex)(-2, 0), (0, complex_1.complex)(-3, 0)];
            const zeros = [(0, complex_1.complex)(0, 0), (0, complex_1.complex)(-4, 0)];
            const frequencyRangeValues = frequencyRange.getDefault(poles, zeros);
            const omegaMin = 0.00001;
            const omegaMax = 10000;
            console.log(Math.min(...frequencyRangeValues));
            console.log(Math.max(...frequencyRangeValues));
            (0, vitest_1.expect)(frequencyRangeValues[0]).toBeGreaterThan(omegaMin);
            (0, vitest_1.expect)(frequencyRangeValues[frequencyRangeValues.length - 1]).toBeLessThan(omegaMax);
        });
        (0, vitest_1.it)('should return a range of frequencies that includes all the poles and zeros', () => {
            const poles = [(0, complex_1.complex)(-1, 2), (0, complex_1.complex)(-1, -2), (0, complex_1.complex)(-10, 0)];
            const zeros = [(0, complex_1.complex)(0, 0)];
            const result = frequencyRange.getDefault(poles, zeros, 10, 100);
            // Check that the result has the expected number of samples
            (0, vitest_1.expect)(result.length).toBe(100);
            // Check that the result is an increasing sequence
            for (let i = 0; i < result.length - 1; i++) {
                (0, vitest_1.expect)(result[i]).toBeLessThan(result[i + 1]);
            }
            // Check that the result is within the expected range
            const expectedMin = 0.00001;
            const expectedMax = 100000;
            (0, vitest_1.expect)(result[0]).toBeGreaterThan(expectedMin);
            (0, vitest_1.expect)(result[result.length - 1]).toBeLessThan(expectedMax);
        });
        (0, vitest_1.it)('should return a range of frequencies that spans at least one decade', () => {
            const poles = [(0, complex_1.complex)(-1, 0), (0, complex_1.complex)(-2, 0), (0, complex_1.complex)(-3, 0)];
            const zeros = [(0, complex_1.complex)(0, 0), (0, complex_1.complex)(-4, 0)];
            const frequencyRangeValues = frequencyRange.getDefault(poles, zeros);
            const omegaMin = 0.00001;
            const omegaMax = 10000;
            (0, vitest_1.expect)(frequencyRangeValues[0]).toBeGreaterThanOrEqual(omegaMin);
            (0, vitest_1.expect)(frequencyRangeValues[frequencyRangeValues.length - 1]).toBeLessThanOrEqual(omegaMax);
        });
    });
});
//# sourceMappingURL=../../../../../src/lib/math/frequencyRange/frequencyRange.spec.js.map