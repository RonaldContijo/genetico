"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const complex_1 = require("../complex");
const PolynomialOperations_1 = require("../polynomialOperations/implementations/PolynomialOperations");
const convolution_1 = require("./convolution");
(0, vitest_1.describe)('IConvolution', () => {
    let convolution;
    let polOps;
    let polOpsMultiplySpy;
    (0, vitest_1.beforeEach)(() => {
        polOps = new PolynomialOperations_1.PolynomialOperations();
        polOpsMultiplySpy = vitest_1.vi.spyOn(polOps, 'multiply');
        convolution = new convolution_1.Convolution(polOps);
    });
    (0, vitest_1.it)('should return the convolved transfer function', () => {
        /**
         *  (s^2 + 2s + 3)/(2s^2 + 3s + 4) convolves  (4s^2 + 5s + 6)/(5s^2 + 6s + 7)
         */
        const tf1 = { numerator: (0, complex_1.toComplex)([1, 2, 3]), denominator: (0, complex_1.toComplex)([2, 3, 4]) };
        const tf2 = { numerator: (0, complex_1.toComplex)([4, 5, 6]), denominator: (0, complex_1.toComplex)([5, 6, 7]) };
        polOpsMultiplySpy.mockReturnValueOnce((0, complex_1.toComplex)([4, 13, 28, 27, 18]));
        polOpsMultiplySpy.mockReturnValueOnce((0, complex_1.toComplex)([10, 27, 57, 63, 52, 28]));
        const expected = { numerator: (0, complex_1.toComplex)([4, 13, 28, 27, 18]), denominator: (0, complex_1.toComplex)([10, 27, 57, 63, 52, 28]) };
        (0, vitest_1.expect)(convolution.execute(tf1, tf2)).toEqual(expected);
    });
    (0, vitest_1.it)('should return the correct convolved transfer function for a transfer function with constant numerator and denominator', () => {
        /**
         * 2/2 convolves 3/3
         */
        const tf1 = { numerator: (0, complex_1.toComplex)([2]), denominator: (0, complex_1.toComplex)([2]) };
        const tf2 = { numerator: (0, complex_1.toComplex)([3]), denominator: (0, complex_1.toComplex)([3]) };
        const expected = { numerator: (0, complex_1.toComplex)([6]), denominator: (0, complex_1.toComplex)([6]) };
        polOpsMultiplySpy.mockReturnValueOnce((0, complex_1.toComplex)([6]));
        polOpsMultiplySpy.mockReturnValueOnce((0, complex_1.toComplex)([6]));
        (0, vitest_1.expect)(convolution.execute(tf1, tf2)).toEqual(expected);
    });
});
//# sourceMappingURL=../../../../../src/lib/math/convolution/convolution.spec.js.map