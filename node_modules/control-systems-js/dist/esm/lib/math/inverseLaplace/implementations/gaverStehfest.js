import { factorial } from '../../../helpers/factorial';
import { add, complex, divide, multiply, pow } from '../../complex';
export class GaverStehfest {
    constructor() {
        this.NUMBER_OF_COEFFICIENTS = 22;
        this.SMALL_NUMBER = 10e-9;
    }
    getCoefficients1(L) {
        const nn2 = L / 2;
        const v = [];
        for (let n = 1; n <= L; n++) {
            let z = complex(0, 0);
            for (let k = Math.floor((n + 1) / 2); k <= Math.min(n, nn2); k++) {
                const num = pow(k, nn2);
                const den = multiply(multiply(multiply(multiply(factorial(nn2 - k), factorial(k)), factorial(k - 1)), factorial(n - k)), factorial(2 * k - n));
                const x = divide(multiply(num, factorial(2 * k)), den);
                z = add(z, x);
            }
            v[n - 1] = multiply(pow(-1, n + nn2), z);
        }
        return v;
    }
    /**
     * Based on the implementations of the following links
     * https://github.com/jlapeyre/InverseLaplace.jl/blob/master/src/gaverstehfest.jl
     * https://www.cs.hs-rm.de/~weber/lapinv/gavsteh/gavsteh.htm
     * https://www.mathworks.com/matlabcentral/fileexchange/9987-gaver-stehfest-algorithm-for-inverse-laplace-transform
     * https://mpmath.org/doc/current/calculus/inverselaplace.html
     *
     * And the original research from Stehfest
     *
     * @param fn Laplace function to be transformed
     * @param t Time for the function to be evaluated at
     * @param L The number of coefficients. It depends on the computer word length used (examples: L=8, 10, 12, 14, 16, etc.)
     * @returns
     */
    gavsteh(fn, t, L) {
        const coefficients = this.getCoefficients1(L);
        const nonZeroTime = t || this.SMALL_NUMBER;
        let sum = complex(0, 0);
        const ln2onT = divide(Math.log(2.0), t || nonZeroTime); // Avoid division by zero
        for (let n = 1; n <= L; n++) {
            const p = multiply(n, ln2onT);
            sum = add(sum, multiply(coefficients[n - 1], fn(complex(p, 0))));
        }
        return multiply(sum, ln2onT);
    }
    /**
     * This function is an implementation of the Gaver-Stehfest method for numerical inverse Laplace transform.
     * The algorithm uses a summation of the function values evaluated at specific values,
     * multiplied by coefficients calculated using a combination of factorials and powers.
     * @param fn Laplace function to be transformed
     * @param time Time for the function to be evaluated at
     * @returns evaluated function value
     */
    execute(fn, time) {
        var _a;
        return (_a = this.gavsteh(fn, time, this.NUMBER_OF_COEFFICIENTS)) === null || _a === void 0 ? void 0 : _a.re;
    }
}
//# sourceMappingURL=../../../../../../src/lib/math/inverseLaplace/implementations/gaverStehfest.js.map