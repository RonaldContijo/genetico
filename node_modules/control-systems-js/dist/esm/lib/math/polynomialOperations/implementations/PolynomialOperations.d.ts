import { Complex } from '../../complex';
import { IPolynomialOperations } from '../PolynomialOperations.entities';
/**
 * This is a naive implementation. The computational time is O(mn) for multiplication and division and O(n) for addition and subtraction
 * There are better algorithms for obtaining the result, especially for multiplication and division
 *
 *
 * "We'll use FFTs to do in O(n log n) time.
 * This is then used in Schonhage-Strassen integer multiplication algorithm that multiplies two n-bit integers in O(n log n loglog n) time.
 * We're only going to dopolynomial multiplication."
 *
 *
 * See [here](http://www.cs.cmu.edu/afs/cs/academic/class/15451-s10/www/lectures/lect0423.txt)
 * and [here](https://www.geeksforgeeks.org/strassens-matrix-multiplication/)
 * for more details
 *
 */
export declare class PolynomialOperations implements IPolynomialOperations {
    /**
     * Validates polynomials arrays
     * @param pol1
     * @param pol2
     */
    private checkPolynomials;
    /**
     * Reversed polynomial order to have the smaller order as the first item of the array
     * @param pol1
     * @param pol2
     */
    private reversePolynomial;
    /**
     * Get the highest polynomial order between two polynomials
     * @param pol1
     * @param pol2
     */
    private getHighestPolynomialOrder;
    add<T extends Complex>(pol1: T[], pol2: T[]): T[];
    subtract<T extends Complex>(pol1: T[], pol2: T[]): T[];
    multiply<T extends Complex>(pol1: T[], pol2: T[]): T[];
    divide<T extends number | Complex>(_pol1: T[], _pol2: T[]): T[];
}
