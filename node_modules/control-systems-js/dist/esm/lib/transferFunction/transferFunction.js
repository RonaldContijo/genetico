import { boundaryRange } from '../helpers/boundaryRange';
import { expressionToString } from '../helpers/expressionToString';
import { groupByIndex } from '../helpers/groupByIndex';
import { range } from '../helpers/range';
import { toComplex } from '../math/complex';
const MAX_ITERATIONS_ROOT = 100;
const PRECISION = 6;
const TOLERANCE = 10e-7;
const DEFAULT_GAINS = range(100);
const DEFAULT_TIME_RANGE = boundaryRange(0, 30, 0.1);
export class TransferFunction {
    constructor(transferFunctionInput, _timeDelay = 0, rootFinder, rootLocus, bode, nyquist, stability, step, impulse, frequencyRange) {
        this.timeRange = DEFAULT_TIME_RANGE;
        this.calculateRoots = (coefficients) => {
            return this.rootFinder.findRoots(coefficients, MAX_ITERATIONS_ROOT, PRECISION, TOLERANCE);
        };
        /**
         * Dependency injection
         */
        this.rootFinder = rootFinder;
        this.rootLocus = rootLocus;
        this.bodeCalculator = bode;
        this.nyquistCalculator = nyquist;
        this.stability = stability;
        this.stepCalculator = step;
        this.impulseCalculator = impulse;
        this.frequencyRangeCalculator = frequencyRange;
        this.validateTransferFunctionInput(transferFunctionInput);
        this.tf = {
            numerator: toComplex(transferFunctionInput.numerator),
            denominator: toComplex(transferFunctionInput.denominator),
        };
        this.zeros = this.calculateRoots(this.tf.numerator);
        this.poles = this.calculateRoots(this.tf.denominator);
        this.frequencyRange = this.frequencyRangeCalculator.getDefault(this.poles, this.zeros);
    }
    validateTransferFunctionInput(input) {
        var _a, _b;
        if (!input || !input.numerator || !input.denominator) {
            throw new Error('Please input a valid transfer function');
        }
        if (((_a = input.numerator) === null || _a === void 0 ? void 0 : _a.length) > ((_b = input.denominator) === null || _b === void 0 ? void 0 : _b.length)) {
            throw new Error('The package only accepts transfer functions where the denominator is a higher order than the numerator');
        }
        if (!this.stability.isStable(input.denominator)) {
            throw new Error(`The given system is unstable. The package doesn't support unstable transfer functions. System: ${JSON.stringify(input)}`);
        }
    }
    toString() {
        const numeratorString = expressionToString(this.tf.numerator);
        const denominatorString = expressionToString(this.tf.denominator);
        return `(${numeratorString}) / (${denominatorString})`;
    }
    getExpression() {
        return this.tf;
    }
    pole() {
        return this.poles;
    }
    zero() {
        return this.zeros;
    }
    mapRootLocusRootsToChart(rootLocusRoots, gains) {
        const groupedRoots = groupByIndex(rootLocusRoots);
        const output = {
            gains,
            roots: groupedRoots.map((roots) => roots.map((root) => ({ x: root.re, y: root.im }))),
        };
        return output;
    }
    rlocus(k = DEFAULT_GAINS) {
        const rootLocusRoots = this.rootLocus.findRootLocus(this.tf, k);
        const chartOutput = this.mapRootLocusRootsToChart(rootLocusRoots, k);
        return chartOutput;
    }
    bode(frequencyRange = this.frequencyRange) {
        const bodeOutput = this.bodeCalculator.calculatePoints(this.getExpression(), frequencyRange);
        return bodeOutput;
    }
    nyquist(frequencyRange = this.frequencyRange) {
        const nyquistPoints = this.nyquistCalculator.calculatePoints(this.getExpression(), frequencyRange);
        return nyquistPoints;
    }
    step(timeRange = this.timeRange) {
        const stepPoints = this.stepCalculator.calculatePoints(this.tf, timeRange);
        return stepPoints;
    }
    impulse(timeRange = this.timeRange) {
        const impulsePoints = this.impulseCalculator.calculatePoints(this.tf, timeRange);
        return impulsePoints;
    }
}
// https://wiki.octave.org/Control_package
//# sourceMappingURL=../../../../src/lib/transferFunction/transferFunction.js.map