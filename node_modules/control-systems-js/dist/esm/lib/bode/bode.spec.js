import { beforeEach, describe, expect, it, vi } from 'vitest';
import { CalculateTransferFunction } from '../math/calculateTransferFunction/implementations/calculateTransferFunction';
import { complex } from '../math/complex';
import { Bode } from './bode';
describe('Bode Class', () => {
    let bode;
    let calculateTransferFunction;
    let calculationSpy;
    beforeEach(() => {
        calculateTransferFunction = new CalculateTransferFunction();
        calculationSpy = vi.spyOn(calculateTransferFunction, 'calculateValue');
        bode = new Bode(calculateTransferFunction);
    });
    it('Should calculate correctly the magnitude data given a set of frequencies', () => {
        //  s + 2 / 2 s + 1
        // f = bodemag(e, 10)
        // f = 0.5093
        const transferFunction = {
            numerator: [complex(1, 0), complex(2, 0)],
            denominator: [complex(2, 0), complex(1, 0)],
        };
        calculationSpy.mockReturnValue(complex(0.5093, 0));
        const result = bode.calculatePoints(transferFunction, [10]);
        expect(result.magnitude[0]).toBeDefined();
        expect(result.magnitude[0].y).toBeCloseTo(-5.8611);
        expect(result.magnitude[0].x).toBe(10);
    });
    it('Should calculate correctly the phase data given a set of frequencies', () => {
        //  s + 2 / 2 s + 1
        const transferFunction = {
            numerator: [complex(1, 0), complex(2, 0)],
            denominator: [complex(2, 0), complex(1, 0)],
        };
        calculationSpy.mockReturnValue(complex(0.5093, 10));
        const result = bode.calculatePoints(transferFunction, [10]);
        expect(result.magnitude[0]).toBeDefined();
        expect(result.magnitude[0].y).toBeCloseTo(20.011);
        expect(result.magnitude[0].x).toBe(10);
    });
});
//# sourceMappingURL=../../../../src/lib/bode/bode.spec.js.map