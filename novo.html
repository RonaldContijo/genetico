<script>
    const VALORES_LIDOS = [27.50,27.75,27.25,27.50,27.75,28.00,27.75,28.00,28.25,28.00,28.00,28.00,28.50,28.75,29.00,29.25,29.00,29.00,29.25,29.75,29.50,30.25,30.00,30.50,30.50,31.00,31.00,31.25,31.25,31.75,31.25,31.50,32.25,32.00,32.00,32.75,32.50,32.75,32.25,33.25,32.75,33.00,33.75,33.50,33.50,33.75,34.00,34.25,34.25,34.50,34.25,34.50,34.75,35.25,35.25,35.00,35.75,35.50,35.50,35.50,35.75,35.00,35.75,35.75,36.00,36.00,36.25,36.25,36.00,36.00,36.25,36.50,36.50,36.50,36.75,36.50,36.75,37.00,36.75,36.75,37.25,37.00,36.75,37.50,37.50,37.25,37.25,37.25,37.00,37.75,37.50,37.75,38.00,37.25,37.50,38.00,37.50,38.00,38.00,38.25,38.25,38.00,38.25,38.25,38.25,38.25,38.50,38.50,38.50,38.25,38.00,38.50,38.50,37.75,38.75,38.75,38.50,38.75,38.75,38.75,38.50,38.75,38.75,38.75,38.75,38.25,38.50,38.50,39.25,39.00,38.75,38.50,38.50,38.75,39.00,39.00,39.00,39.00,38.75,39.00,39.00,39.50,39.00,38.75,38.75,39.00,39.25,39.00,39.50,39.00,39.25,39.25,39.00,38.75,39.25,39.00,39.50,39.00,39.25,39.25,39.50,39.50,39.25,39.50,39.50,39.00,39.25,39.00,39.25,39.25,39.50,39.75,39.00,39.25,39.50,38.75,39.50,39.50,39.75,40.00,39.00,39.75,39.50,39.75,40.00,39.25,39.50,39.25,40.00,39.25,39.25,40.00,39.25,39.50,40.00,39.75,39.75,39.75,39.75,39.50,39.75,39.50,39.75,40.00,39.25,39.75,39.75,39.50,40.00,39.75,40.00,40.00,39.50,39.50,39.75,39.75,39.50,39.75,39.75,40.00,40.00,40.00,40.00,40.25,39.75,39.75,40.00,40.00,40.00,40.00,40.00,39.75,40.00,40.00,39.75,39.50,40.00,40.00,39.75,40.00,40.25,40.00,40.25,40.00,40.50,40.25,39.75,40.00,40.25,40.25,40.25,40.25,40.50,40.25,40.25,39.75,40.50,40.25,40.50,40.50,40.25,40.25,40.50,41.00,40.50,39.75,40.25,40.50,40.25,40.50,40.75,40.50,40.75,40.25,40.50,40.00,40.25,40.50,40.75,40.25,40.25,40.75,40.50,40.25,40.00,40.50,40.50,40.50,40.75,39.75,40.75,40.00,40.50,40.25,40.75,40.50,40.75,40.50,40.25,40.25,40.75,40.75,40.75,40.25,40.50,40.75,40.25,39.75,40.50,40.75,40.75,40.50,40.25,40.50,40.50,40.75,40.50,40.00,40.25,40.75,40.75,40.25,40.25,40.75,40.75,40.50,40.75,40.75,40.50,40.75,40.75,40.25,40.75,40.75,40.75,40.50,40.50,41.00,40.75,40.50,40.75,40.75,40.50,40.50,40.75,40.50,40.25,41.00,40.75,39.75,40.75,40.75,40.50,40.50,40.50,40.50,40.25,40.50,40.75,40.25,40.00,40.75,40.75,40.75,40.75,40.50,40.50,40.25,40.50,40.25,40.75,40.75,40.25,40.50,40.50,40.50,40.25,40.75,40.25,40.75,40.50,40.75,40.75,40.75,40.75,40.25,40.75,39.75,40.00,41.00,40.75,40.75,40.50,40.75,40.50,41.00,40.50,40.75,40.75,40.50,40.50,40.50,40.50,40.50,40.75,40.75,40.75,40.25,40.50,40.50,40.50,40.75,40.75,40.75,40.50,41.00,40.75,40.75,40.75,40.75,40.50,40.75,41.00,41.00,40.50,40.50,40.75,40.00,40.75,40.75,40.75,41.00,40.25,40.75,40.50,41.00,40.25,40.75,41.00,41.00,41.00,41.00,41.00,40.75,40.25,40.75,40.75,40.75,40.75,40.75,41.00,41.00,41.00,41.00,41.00,41.25,41.00,40.75,41.00,41.25,41.00,41.00,41.00];
    
    
    const MUTATION_RATE = 0.2;
    const POPULATION_SIZE = 50;
    const MAX_GENERATIONS = 10000;
    const ELITISMO = false;
    const SELECTION_METHOD = false;
    var melhoresIndividuo = [];
    var pioresIndividuo = [];
    var mediaIndividuos = [];
    var numeroGeracoes = 0;
    var melhorIndividuoResposta = null;


    function geraFuncaoTransferenciaAleatoria() {
        //Math.random gera um n[umero aleatório entre 0 e 1]
        const func = [Math.random() * 40, -Math.random() * 1];
        return func;
    }

    function funcaoTransferencia(A, tau, t) {
        //return A / tau * Math.exp(-t / tau);
        //return A * (1 - Math.exp(-t / tau));
        //return A * (1 - Math.exp(-t / tau)) ;
        return (A*Math.sqrt(tau) -27);

        //return  (A / (tau * t + 1));

        //return A + tau*t;
        //return A * Math.exp(-t / tau);
    }
    /*
    function funcaoTransferencia(A, tau, t, u) {
    return A * (1 - Math.exp(-t / tau)) * u;
}
*/

    function calculateFitness(func) {
        let fitness = 0;
        for (let i = 1; i < VALORES_LIDOS.length; i++) {
            //console.log(Math.abs(VALORES_LIDOS[i] - ((func[0]/(func[1]*i) +1))));
            //fitness += (Math.abs(VALORES_LIDOS[i] - ((func[0] / (func[1] * i) + 1))));

            fitness +=(Math.abs((VALORES_LIDOS[i]) - funcaoTransferencia(func[0],func[1],i)));
            
            //fitness +=(Math.abs(VALORES_LIDOS[i] - funcaoTransferencia(func[0],func[1],i)));
        }
        return fitness;
    }

    function calculateFitnessFin(func) {
        let fitness = 0;
        
        for (let i = 1; i < VALORES_LIDOS.length; i++) {
            console.log("Valores Lidos = "+VALORES_LIDOS[i]);
            console.log("Valores da Funcao = "+funcaoTransferencia(func[0],func[1],i));
            melhorIndividuoResposta.push(funcaoTransferencia(func[0],func[1],i));
            //console.log(Math.abs(VALORES_LIDOS[i] - ((func[0]/(func[1]*i) +1))));
            //fitness += (Math.abs(VALORES_LIDOS[i] - ((func[0] / (func[1] * i) + 1))));
            fitness +=(Math.abs((VALORES_LIDOS[i]) - funcaoTransferencia(func[0],func[1],i)));
        }
        return fitness;
    }
    function sexo(parent1, parent2) {
        
        return [
            Math.random() >= 0.5 ?
                parent1[0] + (Math.abs(parent1[0] - parent2[0]) / 2) :
                parent1[0] - (Math.abs(parent1[0] - parent2[0]) / 2),

            Math.random() >= 0.5 ?
                parent1[1] + (Math.abs(parent1[1] - parent2[1]) / 2) :
                parent1[1] - (Math.abs(parent1[1] - parent2[1]) / 2)
        ];
        
        const litleChild = [
            Math.random() >= 0.5 ?
                parent1[0]:
                parent2[0],

            Math.random() >= 0.5 ?
                parent1[1]:
                parent2[1],
        ];
        return litleChild;
    }

    function mutate(func) {
        return geraFuncaoTransferenciaAleatoria();
        return (
            [
                func[0] * ((11 - (Math.random() * 2)) / 10),
                func[1] * (11 - Math.floor(Math.random() * 1)) / 10,
            ]
        );
    }
    function tournamentSelection(population) {
        const tournamentSize = 5;
        const tournament = [];

        //seleciona 5 individuos aleatoriamente
        for (let i = 0; i < tournamentSize; i++) {
            tournament.push(population[Math.floor(Math.random() * population.length)]);
        }
        //return tournament.reduce((max, current) => (current[1] > max[1] ? current : max));
        return tournament.reduce((min, current) => (current[1] < min[1] ? current : min));

    }

    function rouletteWheelSelection(population) {
        const totalFitness = population.reduce((total, individual) => total + individual[1], 0);
        const randomValue = Math.random() * totalFitness;
        let currentSum = 0;
        for (const individual of population) {
            currentSum += individual[1];
            if (currentSum >= randomValue) {
                return individual;
            }
        }
    }
    let population = Array.from({ length: POPULATION_SIZE }, () => [geraFuncaoTransferenciaAleatoria(), 0]);
    let generation=1;
    for (generation; generation < MAX_GENERATIONS; generation++) {
        population = population.map(([func]) => [func, calculateFitness(func)]);
        

        let fitness = population.map(function (item) {
            return item[1];
        });


        // eExibir a nova lista na console
        //console.log(fitness);

        //informaçoes
        console.log("=========================================");
        console.log(`estamos na ${generation} geração`);
        console.log(`O melhor individuo tem ${Math.min(...fitness)}`);
        console.log(`O pior individuo tem ${Math.max(...fitness)}`);
        const meanFitness = population.reduce((total, [, fitness]) => total + fitness, 0) / POPULATION_SIZE;
        console.log(`A média dos individuos é ${meanFitness}`);

        //armazendando infos pra msotrar no grafico
        melhoresIndividuo.push(Math.min(...fitness));
        pioresIndividuo.push(Math.max(...fitness));
        mediaIndividuos.push(meanFitness);
        numeroGeracoes = generation;


        var bestfunc = Math.min(...fitness);
        let maxIndex = fitness.indexOf(bestfunc);
        melhorIndividuoResposta = population[maxIndex];
        //se existe algum individuo onde não há nenhum par de rainhas se atacando
        //(lembrar q esse 28 é lá de cima do máximo número de ruindade possivel)

        //cria a nova população, os filhos
        const newPopulation = [];

        //Se o usupario selecionar a opção de elitismo o melhor individuo da população
        //anterior sempre vai ser passado pra próxima população
        if (ELITISMO) {
            //alert("Elitismo ligado");
            newPopulation.push(melhorIndividuoResposta);
        }


        while (newPopulation.length < POPULATION_SIZE) {
            /*
            const parent1 = tournamentSelection(population);
            const parent2 = tournamentSelection(population);
            rouletteWheelSelection//implem,entar depois
            */
            //seleção dos individuos
            const parent1 =
                SELECTION_METHOD ?
                    rouletteWheelSelection(population) : tournamentSelection(population);
            const parent2 =
                SELECTION_METHOD ?
                    rouletteWheelSelection(population) : tournamentSelection(population);
            //reprodução dos individuos
            //do amor de duas variaveis nasce uma criancinha
            //que será brutalmente assasinada caso não seja util para a resolução do problema
            let litleChild = sexo(parent1[0], parent2[0]);

            //verificação de mutação
            if (Math.random() < MUTATION_RATE) {
                litleChild = mutate(litleChild);//uma criancinha
            }
            newPopulation.push([litleChild, 0]);
        }

        //Atualiza a população
        population = newPopulation;

        //então...
        //Por algum motivo tinha um desgraçado que era sempre 0
        //population[0] = population[1];
        //agora sumiu
    }
    function funcaoTransferencia(R, tau, t) {
    return R / (tau * t + 1);
}

// Função de transferência de primeira ordem: y(t) = A * (1 - e^(-t / tau))

</script>a